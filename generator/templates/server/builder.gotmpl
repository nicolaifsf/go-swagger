package {{.Package}}
{{ $package := .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "strings"
  "net/http"

  spec "github.com/go-openapi/spec"
  loads "github.com/go-openapi/loads"
  strfmt "github.com/go-openapi/strfmt"
  runtime "github.com/go-openapi/runtime"
  middleware "github.com/go-openapi/runtime/middleware"{{ if .SecurityDefinitions }}
  security "github.com/go-openapi/runtime/security"{{ end }}

  {{ range $key, $value := .DefaultImports }}{{ printf "%s %q" $key $value }}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New{{ pascalize .Name }}API creates a new {{ pascalize .Name }} instance
func New{{ pascalize .Name }}API() *{{ pascalize .Name }}API {
  return &{{ pascalize .Name }}API{
    handlers: make(map[string]map[string]http.Handler),
    formats:  strfmt.Default,
    defaultConsumes: "{{ .DefaultConsumes }}",
    defaultProduces: "{{ .DefaultProduces }}",
    ServerShutdown:  func() {  },
  }
}

/*{{ pascalize .Name }}API {{ if .Info }}{{ if .Info.Description }}{{.Info.Description}}{{ else }}the {{ humanize .Name }} API{{ end }}{{ end }} */
type {{ pascalize .Name }}API struct {
  spec            *loads.Document
  context         *middleware.Context
  handlers        map[string]map[string]http.Handler
  formats         strfmt.Registry
  defaultConsumes string
  defaultProduces string
  {{range .Consumes}}// {{ pascalize .Name }}Consumer registers a consumer for a "{{ .MediaType }}" mime type
  {{ pascalize .Name }}Consumer runtime.Consumer
  {{end}}
  {{range .Produces}}// {{ pascalize .Name }}Producer registers a producer for a "{{ .MediaType }}" mime type
  {{ pascalize .Name }}Producer runtime.Producer
  {{end}}
  {{range .SecurityDefinitions}}
  {{if .IsBasicAuth}}// {{ pascalize .ID }}Auth registers a function that takes username and password and returns a principal
  // it performs authentication with basic auth
  {{ pascalize .ID }}Auth func(string, string) ({{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}, error)
  {{end}}{{if .IsAPIKeyAuth}}// {{ pascalize .ID }}Auth registers a function that takes a token and returns a principal
  // it performs authentication based on an api key {{ .Name }} provided in the {{.Source}}
  {{ pascalize .ID }}Auth func(string) ({{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}, error)
  {{end}}{{ if .IsOAuth2 }}// {{ pascalize .ID }}Auth registers a functin that takes an access token and a collection of required scopes and returns a principal
  // it performs authentication based on an oauth2 bearer token provided in the request
  {{ pascalize .ID }}Auth func(string, []string) ({{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}, error)
  {{ end }}
  {{end}}
  {{range .Operations}}// {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler sets the operation handler for the {{ humanize .Name }} operation
  {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler {{if ne .Package $package}}{{.Package}}.{{end}}{{ pascalize .Name }}Handler
  {{end}}
  // ServeError is called when an error is received, there is a default handler
  // but you can set your own with this
  ServeError     func(http.ResponseWriter, *http.Request, error)

  // ServerShutdown is called when the HTTP(S) server is shut down and done
  // handling all active connections and does not accept connections any more
  ServerShutdown func()

  // Custom command line argument groups with their descriptions
  CommandLineOptionsGroups []swag.CommandLineOptionsGroup

  // User defined logger function.
  Logger          func(string, ...interface{})
}

// SetDefaultProduces sets the default produces media type
func ({{.ReceiverName}} *{{ pascalize .Name }}API) SetDefaultProduces(mediaType string) {
	{{.ReceiverName}}.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func ({{.ReceiverName}} *{{ pascalize .Name }}API) SetDefaultConsumes(mediaType string) {
	{{.ReceiverName}}.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func ({{.ReceiverName}} *{{ pascalize .Name }}API) SetSpec(spec *loads.Document) {
	{{.ReceiverName}}.spec = spec
}

// DefaultProduces returns the default produces media type
func ({{.ReceiverName}} *{{ pascalize .Name }}API) DefaultProduces() string {
	return {{.ReceiverName}}.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func ({{.ReceiverName}} *{{ pascalize .Name }}API) DefaultConsumes() string {
	return {{.ReceiverName}}.defaultConsumes
}

// Formats returns the registered string formats
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Formats() strfmt.Registry {
	return {{.ReceiverName}}.formats
}

// RegisterFormat registers a custom format validator
func ({{.ReceiverName}} *{{ pascalize .Name }}API) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
  {{.ReceiverName}}.formats.Add(name, format, validator)
}

// Validate validates the registrations in the {{ pascalize .Name }}API
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Validate() error {
  var unregistered []string
  {{range .Consumes}}
  if {{.ReceiverName}}.{{ pascalize .Name }}Consumer == nil {
    unregistered = append(unregistered, "{{ pascalize .Name }}Consumer")
  }
  {{end}}
  {{range .Produces}}
  if {{.ReceiverName}}.{{ pascalize .Name }}Producer == nil {
    unregistered = append(unregistered, "{{ pascalize .Name }}Producer")
  }
  {{end}}
  {{range .SecurityDefinitions}}
  if {{.ReceiverName}}.{{ pascalize .ID }}Auth == nil {
    unregistered = append(unregistered, "{{if .IsAPIKeyAuth }}{{ pascalize .Name }}{{ else }}{{ pascalize .ID }}{{ end }}Auth")
  }
  {{end}}
  {{range .Operations}}
  if {{.ReceiverName}}.{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler == nil {
    unregistered = append(unregistered, "{{if ne .Package $package}}{{.Package}}.{{end}}{{ pascalize .Name }}Handler")
  }
  {{end}}

  if len(unregistered) > 0 {
    return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
  }

  return nil
}
// ServeErrorFor gets a error handler for a given operation id
func ({{.ReceiverName}} *{{ pascalize .Name }}API) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
  return {{.ReceiverName}}.ServeError
}
// AuthenticatorsFor gets the authenticators for the specified security schemes
func ({{.ReceiverName}} *{{ pascalize .Name }}API) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
  {{if .SecurityDefinitions}}
  result := make(map[string]runtime.Authenticator)
  for name, scheme := range schemes {
    switch name {
      {{range .SecurityDefinitions}}
      case "{{.ID}}":
        {{if .IsBasicAuth}}_ = scheme
        result[name] = security.BasicAuth({{ if not ( eq .Principal "interface{}" ) }}func(username, password string) (interface{}, error) {
          return {{ end }}{{.ReceiverName}}.{{ pascalize .ID }}Auth{{ if not ( eq .Principal "interface{}" ) }}(username, password)
        }{{ end }}){{end}}
        {{if .IsAPIKeyAuth}}result[name] = security.APIKeyAuth(scheme.Name, scheme.In, {{ if not ( eq .Principal "interface{}" ) }}func(token string) (interface{}, error) {
          return {{ end }}{{.ReceiverName}}.{{ pascalize .ID }}Auth{{ if not ( eq .Principal "interface{}" ) }}(token)
        }{{ end }}){{end}}
        {{if .IsOAuth2}}result[name] = security.BearerAuth(scheme.Name, {{ if not ( eq .Principal "interface{}" ) }}func(token string, scopes []string) (interface{}, error) {
          return {{ end }}{{.ReceiverName}}.{{ pascalize .ID }}Auth{{ if not ( eq .Principal "interface{}" ) }}(token, scopes)
        }{{ end }}){{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// ConsumersFor gets the consumers for the specified media types
func ({{.ReceiverName}} *{{ pascalize .Name }}API) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
  {{if .Consumes}}
  result := make(map[string]runtime.Consumer)
  for _, mt := range mediaTypes {
    switch mt {
      {{range .Consumes}}
      {{range .AllSerializers}}
      case "{{ .MediaType }}":
        result["{{ .MediaType }}"] = {{.ReceiverName}}.{{ pascalize .Name }}Consumer
      {{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// ProducersFor gets the producers for the specified media types
func ({{.ReceiverName}} *{{ pascalize .Name }}API) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
  {{if .Produces}}
  result := make(map[string]runtime.Producer)
  for _, mt := range mediaTypes {
    switch mt {
      {{range .Produces}}
      {{range .AllSerializers}}
      case "{{ .MediaType }}":
        result["{{ .MediaType }}"] = {{.ReceiverName}}.{{ pascalize .Name }}Producer
      {{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// HandlerFor gets a http.Handler for the provided operation method and path
func ({{.ReceiverName}} *{{ pascalize .Name }}API) HandlerFor(method, path string) (http.Handler, bool) {
  if {{.ReceiverName}}.handlers == nil {
    return nil, false
  }
  um := strings.ToUpper(method)
  if _, ok := {{.ReceiverName}}.handlers[um]; !ok {
    return nil, false
  }
  h, ok := {{.ReceiverName}}.handlers[um][path]
  return h, ok
}

func ({{.ReceiverName}} *{{ pascalize .Name }}API) initHandlerCache() {
  if {{.ReceiverName}}.context == nil {
    {{.ReceiverName}}.context = middleware.NewRoutableContext({{.ReceiverName}}.spec, {{.ReceiverName}}, nil)
  }
  {{if .Operations}}
  if {{ .ReceiverName }}.handlers == nil {
    {{.ReceiverName}}.handlers = make(map[string]map[string]http.Handler)
  }
  {{range .Operations}}
  if {{ .ReceiverName }}.handlers[{{ printf "%q" (upper .Method) }}] == nil {
    {{ .ReceiverName }}.handlers[strings.ToUpper({{ printf "%q" (upper .Method) }})] = make(map[string]http.Handler)
  }
  {{.ReceiverName}}.handlers[{{ printf "%q" (upper .Method) }}][{{ printf "%q" .Path }}] = {{if ne .Package $package}}{{.Package}}.{{end}}New{{ pascalize .Name }}({{.ReceiverName}}.context, {{.ReceiverName}}.{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler)
  {{end}}
  {{end}}
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Serve(builder middleware.Builder) http.Handler {
  if len({{.ReceiverName}}.handlers) == 0 {
    {{.ReceiverName}}.initHandlerCache()
  }

  return {{.ReceiverName}}.context.APIHandler(builder)
}
